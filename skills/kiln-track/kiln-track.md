---
name: kiln-track
description: "Main work loop — auto-advances phases through plan, validate, execute, e2e, review, reconcile"
user_invocable: true
---
# /kiln:track — Track Execution Loop

## Overview
`/kiln:track` is the main work loop for kiln delivery. It takes roadmap phases from `.kiln/ROADMAP.md`, reads runtime status from `.kiln/STATE.md`, and drives each phase through the full gate sequence.

The kiln orchestrator (`agents/kiln-orchestrator.md`) executes this skill as a control contract. This skill defines ordering, transitions, retry budgets, pause conditions, and final closeout behavior.

Track scope is phase-complete delivery, not ad-hoc execution. The loop continues until every roadmap phase reaches `complete`, then it triggers Final Integration E2E as a separate terminal gate.

Core loop shape:
- Per-phase flow: `PLAN -> VALIDATE -> EXECUTE -> E2E -> REVIEW -> RECONCILE`
- Cross-phase behavior: auto-advance to next incomplete roadmap phase
- End-of-project behavior: run Final Integration E2E, then write `.kiln/FINAL_REPORT.md`

The orchestrator is routing-only. It does not implement source changes itself; it spawns designated subagents and records machine-readable state transitions.

## Prerequisites
Before running `/kiln:track`, confirm all control-plane artifacts exist:

- `.kiln/config.json` — project configuration produced by `/kiln:init`
- `.kiln/VISION.md` — operator-approved vision from `/kiln:brainstorm`
- `.kiln/ROADMAP.md` — phase decomposition from `/kiln:roadmap`
- `.kiln/STATE.md` — initialized pipeline state ledger

Prerequisite handling contract:

1. If any prerequisite is missing, stop immediately.
2. Print the missing path(s) and the exact command the operator must run.
3. Do not attempt fallback generation inside `/kiln:track`.

Operator guidance map for missing files:

| Missing file | Required command |
| --- | --- |
| `.kiln/config.json` | `/kiln:init` |
| `.kiln/VISION.md` | `/kiln:brainstorm` |
| `.kiln/ROADMAP.md` | `/kiln:roadmap` |
| `.kiln/STATE.md` | `/kiln:init` then `/kiln:status` check |

Example stop message format:

```text
Cannot run /kiln:track: missing .kiln/ROADMAP.md.
Run /kiln:roadmap first, then rerun /kiln:track.
```

## Track Loop
Run the loop exactly in this sequence:

1. Read `.kiln/STATE.md` to determine the active phase, active step, counters, and gate status.
2. If no current phase is active, read `.kiln/ROADMAP.md` and select the first incomplete phase.
3. Execute the current step for the current phase:
   a. `PLAN` — branch by `.kiln/config.json` `preferences.useTeams`:
      - `false` or absent: existing sequential Task spawns (`kiln-planner`, optional `kiln-codex-planner`, optional `kiln-synthesizer`) to produce canonical `PLAN.md`.
      - `true` + `modelMode: "multi-model"`: run stage-scoped planning team scheduler (see PLAN stage Teams mode), including dependent validator task and `plan-validation-result` sentinel emission.
      - `true` + `modelMode: "claude-only"`: force non-Teams Task spawning for PLAN.
   b. `VALIDATE` — branch by `preferences.useTeams`:
      - `false` or absent: spawn `kiln-validator` (Sonnet) for 7-dimension plan validation.
      - `true`: consume `plan-validation-result` generated by the PLAN team and enforce gate pass/fail semantics.
   c. `EXECUTE` — branch by `preferences.useTeams`:
      - `false` or absent: existing sequential/non-Teams execution (`kiln-sharpener` -> `kiln-executor` -> mini-verify per task).
      - `true`: run Teams wave scheduler (one team per wave, one wave-worker teammate per task packet) with worktree/copy-back/integration-verify protocol.
   d. `E2E` — spawn `kiln-e2e-verifier` (Sonnet).
   e. `REVIEW` — branch by review mode:
      - `reviewStrategy: "single"`: spawn `kiln-reviewer` (Opus) as before.
      - `reviewStrategy: "debate"` + `preferences.useTeams: true` + `modelMode: "multi-model"`: run review debate team scheduler (parallel reviewers + critique/revise rounds).
      - `reviewStrategy: "debate"` + `preferences.useTeams: true` + `modelMode: "claude-only"`: skip Teams review debate and run non-Teams single-reviewer path.
      - `reviewStrategy: "debate"` + `preferences.useTeams: false|absent`: existing sequential Task spawn debate flow.
   f. `RECONCILE` — run reconciliation protocol via `/kiln:reconcile` (`skills/kiln-reconcile/kiln-reconcile.md`).
4. After each step completes: if `PASS`, advance to the next step and update `.kiln/STATE.md`; if `FAIL`, check correction budget, run correction flow when budget remains, otherwise `HALT`.
5. After `RECONCILE` completes for a phase: mark phase complete in `.kiln/STATE.md`, move to next incomplete phase; if none remain, trigger Final Integration E2E.
6. After Final Integration E2E passes: generate `.kiln/FINAL_REPORT.md`, mark project complete, and set state to terminal success.

Transition invariants:
- Only one active phase and one active step at a time.
- Every transition writes timestamped state before downstream spawn.
- Retry/correction counters are monotonic and persisted per phase.
- On any halt threshold, transition to failed state and wait for operator direction.

## Stage Details

### PLAN stage

#### Purpose
Convert phase intent from `ROADMAP.md` into executable task packets for this specific phase.

#### Subagents to spawn
- Always spawn `kiln-planner` (Opus lane).
- In `multi-model` mode, also spawn `kiln-codex-planner` (Codex lane).
- In `multi-model` mode with `planStrategy: "synthesize"` (default), spawn `kiln-synthesizer` after both planners complete.
- In `multi-model` mode with `planStrategy: "debate"`, run debate rounds before synthesis (see Debate Flow below).

#### Teams mode selector (`preferences.useTeams`)
- `false` or absent: use the existing sequential Task spawning model documented in this section.
- `true` + `modelMode: "multi-model"`: use explicit Teams scheduling for plan generation (and dependent validation) as defined below. Team/task identity and payload semantics must conform to `skills/kiln-teams/kiln-teams.md`.
- `true` + `modelMode: "claude-only"`: use non-Teams Task spawn for PLAN regardless of `preferences.useTeams`. Teams planning requires both planners.

#### Teams scheduler (PLAN)
When `preferences.useTeams: true` and `modelMode: "multi-model"`, PLAN is executed as a dependency graph inside one stage-scoped planning team for the active phase:

1. Create planning team scoped to phase `phase-N`.
2. Create planner tasks:
   - Always create Opus planner task (`phase-N:plan:planner-opus`).
   - In `multi-model`, also create Codex planner task (`phase-N:plan:planner-codex`).
3. Run planner tasks in parallel.
4. If `multi-model`, run synthesizer task (`phase-N:plan:synthesizer`) after all planner tasks complete.
5. Run validator as a dependent task (`phase-N:plan:validator`) after synthesis, folded into the same planning team.
6. Validator task emits `plan-validation-result`; orchestrator treats this sentinel as the VALIDATE gate input.

Required PLAN-team outputs:
- Canonical `.kiln/tracks/phase-N/PLAN.md`.
- `plan-validation-result` sentinel available for gate advancement.

#### Mode behavior
- `multi-model` with `planStrategy: "synthesize"` (default):
  - Outputs expected: `.kiln/tracks/phase-N/plan_claude.md`, `.kiln/tracks/phase-N/plan_codex.md`, and synthesized `.kiln/tracks/phase-N/PLAN.md`.
  - `PLAN.md` is authoritative for downstream stages.
- `multi-model` with `planStrategy: "debate"`:
  - Both planners produce initial plans (parallel, as above).
  - Debate rounds run per the `kiln-debate` protocol.
  - Synthesizer merges final revisions with debate context.
  - `PLAN.md` is authoritative for downstream stages.
- `claude-only`:
  - Only `kiln-planner` runs.
  - Planner output is promoted/copied as `.kiln/tracks/phase-N/PLAN.md`.
  - No codex planner, no debate, and no synthesizer pass.
  - Debate preferences in config.json are ignored.

#### Plan Debate Flow
When `planStrategy: "debate"` and `modelMode: "multi-model"`:

```
1. Spawn kiln-planner and kiln-codex-planner in parallel
   -> plan_claude.md, plan_codex.md

2. For round = 1 to debateRounds:
   a. Critique phase (parallel):
      - Spawn kiln-planner in critique mode (reads plan_codex latest, writes critique_of_codex_r<round>.md)
      - Spawn kiln-codex-planner in critique mode (reads plan_claude latest, writes critique_of_claude_r<round>.md)

   b. Revise phase (parallel):
      - Spawn kiln-planner in revise mode (reads critique_of_claude_r<round>.md, writes plan_claude_v<round+1>.md)
      - Spawn kiln-codex-planner in revise mode (reads critique_of_codex_r<round>.md, writes plan_codex_v<round+1>.md)

   c. Convergence check:
      - Read both critiques from this round.
      - If convergence criteria met (per kiln-debate protocol), break early.
      - Record round result in debate_log.md.

3. Write debate_log.md with full audit trail.

4. Spawn kiln-synthesizer with debate context:
   - Final revised plans as primary inputs
   - All critique artifacts for context
   - debate_log.md for convergence info
   -> PLAN.md
```

State tracking for debate:
- Track `debateRound` counter in `.kiln/STATE.md` phase metadata.
- Record convergence status after each round.
- On debate failure (both participants fail in same round), proceed to synthesis with best available versions.

#### Required output
`PLAN.md` must contain task packets with goals, ACs, files, dependencies, waves, and rollback context as defined by `skills/kiln-plan/kiln-plan.md`.

#### Exit conditions
- `PASS`: `PLAN.md` exists and is parseable for validation; in Teams mode, `plan-validation-result` sentinel is present with pass status.
- `FAIL`: planning artifact missing, malformed, or cannot be promoted to canonical `PLAN.md`.

#### State updates
- Set `currentStep: validate` on pass.
- Record planning artifact paths in phase metadata.
- On fail, increment plan retry metadata and route to re-plan if budget remains.

### VALIDATE stage

#### Purpose
Quality-gate the phase plan using the 7-dimension validation contract.

#### Subagent to spawn
- `preferences.useTeams: false|absent` — spawn `kiln-validator` with `PLAN.md` and relevant living docs.
- `preferences.useTeams: true` — validator runs as dependent PLAN-team task (`phase-N:plan:validator`); VALIDATE consumes its sentinel output.

Teams mode gate contract (`preferences.useTeams: true`):
- Do not spawn a second validator by default.
- Read the `plan-validation-result` produced by `phase-N:plan:validator`.
- Required keys must be present exactly as defined by kiln-core: `sentinel`, `phase`, `status`, `validator`, `plan_path`, `checks`.
- Missing criteria: any required key absent.
- Malformed criteria:
  - `status` is not exactly `pass` or `fail`.
  - `phase` is not exactly `phase-N` for the active phase.
  - `checks` is not a structured checks collection.
  - `plan_path` is not the canonical phase plan location.
- Canonical `plan_path` rule: after path normalization, `plan_path` must resolve to `.kiln/tracks/phase-N/PLAN.md` (absolute-path equivalent resolving to the same file is allowed).
- Stale criteria: sentinel `phase` does not match the currently active phase or `plan_path` resolves outside the active phase path.
- Gate decision:
  - If sentinel is missing, malformed, stale, or `status: fail`, treat VALIDATE as failed and route to planning correction flow.
  - If sentinel is valid and `status: pass`, mark VALIDATE pass and advance to `EXECUTE`.

#### Validation contract
- Must run all 7 dimensions from `kiln-plan` specification.
- Must emit machine-readable `plan-validation-result` sentinel.

#### Pass behavior
- Mark validation pass in state.
- Advance to `EXECUTE` for the same phase.

#### Fail behavior
- Route feedback back into planning.
- Re-trigger planning with validator findings attached.
- Maximum re-plan attempts: 2 for the same phase.
- After second failed validation cycle, `HALT` and wait for operator.

#### State updates
- Track `planValidationAttempts` per phase.
- Persist failure reasons and validator artifact path.
- Timestamp each validation result transition.

### EXECUTE stage

#### Purpose
Implement all phase task packets safely and deterministically.

#### Input contract
- Read tasks from `.kiln/tracks/phase-N/PLAN.md`.
- Respect wave ordering and dependencies.

#### Execution protocol
1. Parse wave table and task IDs from `PLAN.md`.
2. Process waves sequentially (`wave-1`, then `wave-2`, etc.).
3. Inside each wave, run tasks in parallel when dependency-safe.
4. For each task:
   - Spawn `kiln-sharpener` to produce an implementation packet for the executor model.
   - Spawn `kiln-executor` to implement the task.
   - Run mini-verify (`/kiln:verify`) against task acceptance criteria.
5. Persist task-level results and counters into `.kiln/STATE.md`.

#### Teams mode selector (`preferences.useTeams`)
- `false` or absent: use the existing non-Teams execution protocol above (sequential Task spawning model with dependency-safe wave parallelism).
- `true`: use explicit Teams wave scheduler below. Worktree/copy-back semantics are normative from `skills/kiln-teams/kiln-teams.md` and `skills/kiln-execute/kiln-execute.md`.

#### Teams wave scheduler (EXECUTE)
When `preferences.useTeams: true`:

1. Parse waves from `.kiln/tracks/phase-N/PLAN.md`.
2. For each wave in order (`wave-1`, `wave-2`, ...), create one wave team scoped to that wave.
3. Create one `kiln-wave-worker` teammate per task packet in the wave.
4. Each worker runs in isolated worktree at `${KILN_WORKTREE_ROOT:-/tmp}/kiln-<project-hash>/<task-id>/`, with `.kiln` symlinked to canonical control plane.
5. Worker flow is `sharpen -> execute -> explicit mini-verify -> TaskUpdate`; workers must not commit in worktrees.
6. After worker success, orchestrator performs deterministic copy-back to main workspace (preserving rename/delete/add/modify/untracked semantics; excluding `.kiln/**` except task artifacts).
7. Orchestrator creates atomic task commits on main after copy-back.
8. After all successful copy-backs in the wave, run integration verify on main before starting next wave.

Cancellation protocol (fail-fast within a wave):
- Any worker failure triggers orchestrator shutdown requests to all other in-flight workers in that wave.
- Workers receiving shutdown emit shutdown acknowledgement and stop new mutations.
- Failed worker worktree is preserved for forensics; do not clean it up automatically.
- Orchestrator records failure evidence paths before rerun/halt decision.

#### Retry budget
- Mini-verify retries: max 2 per task.
- On retryable failure, rerun sharpen -> execute -> mini-verify for that task only.
- If a task hits mini-verify retry limit, set phase step to failed and `HALT`.

#### Concurrency rules
- Waves: strictly sequential.
- Tasks within a wave: parallel allowed only when they do not modify the same file set and do not depend on each other.

#### Exit conditions
- `PASS`: all tasks in all waves satisfy mini-verify.
- `FAIL`: any task exceeds mini-verify retry budget.

#### State updates
- Maintain per-task status (`queued`, `in_progress`, `done`, `blocked`, `halted`).
- Increment `correctionCycles.miniVerify` on each retry.
- Write transition timestamps for each task completion/failure.

### E2E stage

#### Purpose
Validate that the full phase behavior works end-to-end and does not regress prior behavior.

#### Subagent to spawn
- Spawn `kiln-e2e-verifier` after execute pass.

#### Required test scope
- New user-journey coverage introduced by this phase.
- Cumulative regression checks relevant to previously completed phases.

#### Correction loop
- On E2E fail, consume correction packets from `e2e-results.md`.
- Route corrections through execution flow (sharpen -> execute -> mini-verify).
- Re-run E2E after correction batch.
- Maximum E2E correction cycles: 3 per phase.

#### Exit conditions
- `PASS`: E2E sentinel reports pass and no blocking failures.
- `FAIL`: third correction cycle still failing -> `HALT`.

#### State updates
- Increment `correctionCycles.e2e` each failed E2E cycle.
- Store E2E artifact path in phase metadata.
- Timestamp each cycle boundary.

### REVIEW stage

#### Purpose
Apply comprehensive quality review after implementation and E2E validation.

#### Subagent to spawn
- Always spawn `kiln-reviewer` (Opus) on E2E pass.
- When `reviewStrategy: "debate"` and `modelMode: "multi-model"`, also spawn `kiln-codex-reviewer` (GPT-5.3-codex-sparks).

#### Mode behavior
- `reviewStrategy: "single"` (default):
  - Only `kiln-reviewer` runs. Standard single-perspective review.
- `reviewStrategy: "debate"`:
  - Both reviewers produce independent reviews.
  - Debate rounds run per the `kiln-debate` protocol.
  - Final verdict incorporates both perspectives.
- `claude-only`:
  - Only `kiln-reviewer` runs regardless of `reviewStrategy` setting.

#### Teams mode selector (`preferences.useTeams`)
- `false` or absent: use the existing sequential Task spawning model for review and review debate.
- `true`:
  - `reviewStrategy: "single"` remains unchanged (single reviewer path; no review team scheduler required).
  - `reviewStrategy: "debate"` + `modelMode: "multi-model"` uses the explicit review debate team scheduler below.
  - `reviewStrategy: "debate"` + `modelMode: "claude-only"` skips Teams review debate regardless of `preferences.useTeams`.

#### Review Debate Flow
When `reviewStrategy: "debate"` and `modelMode: "multi-model"`:

Teams scheduler for debate mode (`preferences.useTeams: true`):
- Create one review team for phase `phase-N`.
- Spawn both reviewers as parallel teammates:
  - `phase-N:review:opus-initial` -> `.kiln/tracks/phase-N/review.md`
  - `phase-N:review:codex-initial` -> `.kiln/tracks/phase-N/review_codex.md`
- For each round `r` from `1..debateRounds`:
  - Critique tasks in parallel:
    - Opus critique -> `.kiln/tracks/phase-N/critique_of_review_codex_r<r>.md`
    - Codex critique -> `.kiln/tracks/phase-N/critique_of_review_opus_r<r>.md`
  - Revise tasks in parallel:
    - Opus revision -> `.kiln/tracks/phase-N/review_v<r+1>.md`
    - Codex revision -> `.kiln/tracks/phase-N/review_codex_v<r+1>.md`
  - Append round result to `.kiln/tracks/phase-N/debate_log.md`; allow early stop on convergence.
- Final verdict rule is unchanged: stricter verdict wins (`REJECTED` over `APPROVED`), with Opus reviewer final artifact authoritative where required by contract.

Sequential fallback (`preferences.useTeams: false|absent`):
```
1. Spawn kiln-reviewer and kiln-codex-reviewer in parallel
   -> review.md, review_codex.md

2. For round = 1 to debateRounds:
   a. Critique phase (parallel):
      - Spawn kiln-reviewer in critique mode (reads review_codex latest, writes critique_of_review_codex_r<round>.md)
      - Spawn kiln-codex-reviewer in critique mode (reads review latest, writes critique_of_review_opus_r<round>.md)

   b. Revise phase (parallel):
      - Spawn kiln-reviewer in revise mode (reads critique_of_review_opus_r<round>.md, writes review_v<round+1>.md)
      - Spawn kiln-codex-reviewer in revise mode (reads critique_of_review_codex_r<round>.md, writes review_codex_v<round+1>.md)

   c. Convergence check:
      - Read both critiques from this round.
      - If convergence criteria met (per kiln-debate protocol), break early.
      - Append round result to debate_log.md.

3. Update debate_log.md with review debate audit trail.

4. Final verdict determination:
   - Read both final revised reviews.
   - Agreement on findings = high-confidence issues (always include).
   - Single-reviewer findings = evaluate on individual merit.
   - The Opus reviewer's final revision is the authoritative verdict.
   - If verdicts disagree: the stricter verdict wins (REJECTED beats APPROVED).
```

State tracking for review debate:
- Track `reviewDebateRound` counter in `.kiln/STATE.md` phase metadata.
- Record convergence status after each round.
- On debate failure, fall back to Opus reviewer's latest verdict.

#### Verdict handling
- `APPROVED`:
  - Advance directly to `RECONCILE`.
- `REJECTED`:
  - Use reviewer correction packets (from the authoritative final review).
  - Route corrections through `EXECUTE` then `E2E` then `REVIEW`.
  - Maintain strict cycle counting.

#### Correction budget
- Maximum review correction cycles: 3 per phase.
- If review remains rejected after 3 cycles, `HALT`.
- Debate rounds do NOT count toward correction cycles. Debate is part of a single review pass.

#### Exit conditions
- `PASS`: reviewer verdict approved (post-debate if debate is active).
- `FAIL`: correction budget exhausted.

#### State updates
- Increment `correctionCycles.review` per rejected cycle.
- Persist review artifact path and top findings summary.
- Timestamp verdict transitions.

### RECONCILE stage

#### Purpose
Bring living docs and state in sync with actual delivered behavior for the phase.

#### Skill/action to run
- Run `/kiln:reconcile` to produce documentation reconciliation outputs.

#### Required outputs
- Updates to `.kiln/docs/*` as needed.
- `.kiln/tracks/phase-N/reconcile.md` with change log and unresolved doc debt.
- Proposed state transition to mark phase complete.

#### Operator gate
- Present reconcile changes for explicit operator confirmation.
- Do not finalize phase completion without confirmation.

#### Exit conditions
- `PASS`: operator confirms reconcile outputs and no unresolved blocking doc issues.
- `FAIL`: reconcile artifact missing, invalid, or operator declines changes pending edits.

#### State updates
- On pass, mark phase `complete`, clear `currentStep`, and select next incomplete phase.
- On no remaining phases, set `currentStep: final-integration-e2e`.
- Always append transition timestamps and operator confirmation note.

## Transition Messages

Before spawning the next stage's subagent, the orchestrator emits a transition message drawn from `skills/kiln-lore/kiln-lore.md`. This provides rhythm at each stage boundary.

**Protocol:**
1. Read the matching transition section from `skills/kiln-lore/kiln-lore.md` for the stage about to begin.
2. Select one quote contextually (AI picks based on project situation — no shell commands).
3. Display using the canonical format, then spawn the subagent.

**Transition keys at each track boundary:**

| Boundary | Lore Key | When |
| --- | --- | --- |
| Phase entry | `phase-start` | Starting a new phase from ROADMAP.md |
| Before PLAN | `plan` | Spawning planner(s) for the phase |
| Before VALIDATE | `validate` | Spawning validator after plan is produced |
| Before EXECUTE | `execute` | Spawning wave workers / executor pipeline |
| Before E2E | `e2e` | Spawning E2E verifier after execution pass |
| Before REVIEW | `review` | Spawning reviewer after E2E pass |
| Before RECONCILE | `reconcile` | Spawning reconciler after review approval |
| Phase exit | `phase-complete` | Phase reconcile confirmed, advancing to next |

Transition messages do not alter stage logic, gate conditions, or retry budgets. They are display-only markers between stages.

## Pause Conditions
Pause the track loop under these exact conditions:

1. After `RECONCILE`, pause for operator confirmation of living-doc changes.
2. On any `HALT` where correction budget is exhausted (mini-verify, E2E, or review).
3. On plan validation failure after 2 re-plan attempts for the same phase.
4. If the operator types `pause`, stop after the current step completes and persist resumable state.

Pause behavior contract:
- Persist `.kiln/STATE.md` before responding to operator.
- Report current phase, current step, counters, and next required action.
- Resume only when operator explicitly requests continuation.

## Final Integration E2E
Final Integration E2E is a terminal project gate that runs only after all roadmap phases are complete.

Trigger conditions:
- Every phase listed in `.kiln/ROADMAP.md` is marked `complete` in `.kiln/STATE.md`.
- No phase is in `failed` or `in-progress` state.

### Cross-Cutting Test Generation Protocol
Generate integration coverage before running the terminal suite.

1. Read every phase plan file at `.kiln/tracks/phase-*/PLAN.md`.
2. Extract acceptance criteria from all phases into a combined checklist.
3. Identify cross-cutting user journeys that span two or more phases:
   - Data flows: data created in an earlier phase is visible and usable in later-phase features.
   - Auth flows: authenticated users can traverse capabilities introduced across multiple phases.
   - Integration flows: components/services delivered in different phases interoperate correctly.
4. Prioritize highest-risk journeys (critical paths, shared state, auth boundaries, multi-service dependencies).
5. Generate 3-5 critical cross-cutting E2E tests (not exhaustive full matrix coverage).
6. Write generated cross-cutting tests to `tests/e2e/integration/`.
7. Keep generated tests deterministic and runnable in the same E2E harness used by phase suites.

Minimum output contract:
- `tests/e2e/integration/` contains 3-5 executable tests.
- Each test maps to at least one cross-phase journey and references impacted phase AC IDs in comments or test metadata.

### Full Regression Execution Protocol
Run the complete regression surface for the project, not only newly generated tests.

Execution order:
1. Run all per-phase E2E suites from `tests/e2e/phase-*/`.
2. Run all cross-cutting integration suites from `tests/e2e/integration/`.
3. Aggregate results into a single terminal integration verdict.

Regression handling contract:
- Any failure in `tests/e2e/phase-*/` is a CRITICAL regression bug because previously validated behavior has broken.
- Regression failures receive highest correction priority ahead of non-regression defects.
- The gate cannot pass while any regression test remains failing.

### Correction Protocol
Apply bounded correction cycles with full-suite revalidation.

Cycle rules:
- Maximum 3 correction cycles for Final Integration E2E.
- Each cycle must follow the same correction pipeline used elsewhere:
  1. Sharpen correction packet(s).
  2. Implement fixes.
  3. Run mini-verify on impacted task criteria.
  4. Re-run Final Integration E2E.
- After each correction cycle, re-run the FULL integration suite:
  - `tests/e2e/phase-*/`
  - `tests/e2e/integration/`
- Do not run only previously failed tests as the terminal gate decision.

Cycle exhaustion behavior:
- On failure after cycle 3, `HALT` with full context.
- Persist failure evidence using the error-escalation contract from `skills/kiln-core/kiln-core.md`:
  - commands run, logs, repro steps, attempt history, ranked hypotheses, and gate status sentinel.
- Report blocking regressions and unresolved integration defects to operator with actionable next decision.

### Success Criteria
Final Integration E2E passes only when all of the following are true:
- All per-phase regression tests pass (`tests/e2e/phase-*/`).
- All cross-cutting integration tests pass (`tests/e2e/integration/`).
- No new critical issues are discovered in the terminal suite.

### Terminal Outcomes
On `PASS`:
- Generate `.kiln/FINAL_REPORT.md` from `templates/FINAL_REPORT.md.tmpl`.
- Populate report fields from `.kiln/STATE.md`, `.kiln/ROADMAP.md`, phase artifacts, and final E2E/review outputs.
- Mark project state as complete with completion timestamp.

On `FAIL` after 3 cycles:
- `HALT` with full context.
- Record failure artifacts, attempted fixes, and blocking defects.
- Wait for operator direction.

## State Tracking
`/kiln:track` relies on `.kiln/STATE.md` as the single source of truth for loop progress.

Required fields:
- `currentPhase`
- `currentStep`
- `correctionCycles` with counters for `e2e`, `review`, and `miniVerify`
- Phase progress table with status for each roadmap phase
- Transition timestamps for every step and phase change

STATE.md follows the canonical Markdown schema defined in kiln-core. See `skills/kiln-core/kiln-core.md` section "STATE.md Canonical Schema" and `templates/STATE.md.tmpl` for the authoritative format. Do not use YAML or any alternative state representation.

Phase progress requirements:
- Include every roadmap phase, even those not started yet.
- Allowed statuses: `pending`, `in-progress`, `complete`, `failed`.
- Keep phase ordering identical to `ROADMAP.md`.

Transition timestamp requirements:
- Write an ISO 8601 UTC timestamp for each transition.
- Record both successful and failed transitions.
- Include the artifact path that informed each gate decision when available.

Counter requirements:
- Counters reset when moving to a new phase.
- Counters do not reset within correction cycles of the same phase.
- Counters must survive process interruptions and resume safely.

State integrity rules:
- Never advance `currentStep` without writing state.
- Never mark phase complete before reconcile confirmation.
- Never start Final Integration E2E until all phases are complete.
- On inconsistency between roadmap and state, pause and escalate to operator.

This contract is normative for `/kiln:track`. If a subagent output conflicts with this skill, follow this skill's sequencing and gate rules, then request corrected subagent output as needed.
