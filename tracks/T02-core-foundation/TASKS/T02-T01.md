# T02-T01: Write kiln-core skill

## GOAL
Write the kiln-core skill — the constitution that defines all universal invariants, agent coordination contracts, model routing, state layer schema, and output format specifications that every downstream agent and skill depends on.

## ACCEPTANCE_CRITERIA
- AC-01 (LLM): Defines all agent coordination contracts: .kiln/ directory structure and file purposes, output format contracts between agents (what each agent reads and writes), sentinel schema format (YAML blocks in markdown for machine-readable output), error escalation protocol (max retries, halt conditions)
- AC-04 (LLM): Covers model routing table for all 13 roles with multi-model and Claude-only columns, Claude-only fallback rules (what gets skipped vs adapted), context budget guidelines (~15% orchestrator, fresh 200k context per task)

## FILES
- path: skills/kiln-core/kiln-core.md
  action: add
  rationale: The foundational skill referenced by every agent and skill in the kiln system

## COMMANDS
- `test -f skills/kiln-core/kiln-core.md` — file exists
- `wc -l skills/kiln-core/kiln-core.md` — should be ~200-400 lines

## SUMMARY
Create the file `skills/kiln-core/kiln-core.md`. This is a markdown file that serves as a "skill" — a behavioral module injected into Claude Code agents. It is the foundational reference document for a system called "kiln" — a multi-model orchestration workflow for Claude Code.

**Context for the implementer:** Kiln is an NPM package (`kiln-dev`) that orchestrates code generation using multiple AI models (Claude + GPT via Codex CLI). It uses a pipeline: brainstorm -> roadmap -> per-track loop (plan -> validate -> execute -> E2E test -> review -> reconcile). All state lives in a `.kiln/` directory in the user's project. This skill defines the contracts that all 11 agents and 7 skills in the system must follow.

Start the file with this YAML frontmatter block:

```
---
name: kiln-core
description: Universal invariants and coordination contracts for the kiln workflow
---
```

Then write a markdown document with a top-level heading `# Kiln Core — Universal Contracts` followed by these 8 sections. Each section must be thorough and prescriptive — agents will read this at runtime and must follow it exactly.

### Section 1: `.kiln/` Directory Structure

Write a heading `## 1. State Layer — .kiln/ Directory Structure`. Explain that all kiln state lives in a `.kiln/` directory at the project root. Everything in `.kiln/` is committed to git for full auditability. Then show this exact directory tree in a code block:

```
.kiln/
├── config.json              # Project settings: tooling, model mode, preferences
├── VISION.md                # Permanent north star (from brainstorm, immutable after approval)
├── ROADMAP.md               # High-level phases (directional, lightweight)
├── STATE.md                 # Persistent progress tracking (survives session restarts)
├── FINAL_REPORT.md          # Generated after final integration E2E
├── docs/                    # Living documents (evolve per track via reconciliation)
│   ├── TECH_STACK.md        # Languages, frameworks, dependencies with versions
│   ├── PATTERNS.md          # Architecture patterns, naming conventions, file structure
│   ├── DECISIONS.md         # Decision records with rationale and context
│   └── PITFALLS.md          # Known gotchas, anti-patterns discovered during development
└── tracks/
    └── phase-N/             # Per-track artifacts (one directory per roadmap phase)
        ├── plan_claude.md   # Opus planning perspective
        ├── plan_codex.md    # GPT-5.2 planning perspective (multi-model only)
        ├── PLAN.md          # Synthesized master plan with task packets
        ├── e2e-results.md   # Runtime verification results
        ├── review.md        # Code review output
        ├── reconcile.md     # Living doc changes log
        └── artifacts/       # Screenshots, recordings, logs
```

After the tree, add a brief note: "VISION.md is immutable after operator approval. If the vision changes, re-brainstorm. Living docs in docs/ have a soft budget of ~3000 words each — reconciliation replaces outdated entries rather than appending indefinitely."

### Section 2: Model Routing Table

Write a heading `## 2. Model Routing`. Add a brief intro: "Each role in the pipeline has a specific model assignment. Multi-model mode uses GPT models via Codex CLI for three roles where model-family affinity or diverse perspective matters. Claude-only mode is a functional fallback."

Then write this exact markdown table:

```
| Role | Multi-Model | Claude-Only | Rationale |
|------|-------------|-------------|-----------|
| Orchestrator | Opus 4.6 | Opus 4.6 | Deep reasoning for routing decisions |
| Brainstormer | Opus 4.6 | Opus 4.6 | Facilitation needs deep reasoning |
| Vision Challenger | GPT-5.2-high (Codex CLI) | *skipped* | Fresh eyes on brainstorm output |
| Vision Synthesizer | Opus 4.6 | *skipped* | Merges brainstorm + critique |
| Planner A | Opus 4.6 | Opus 4.6 | Architectural perspective |
| Planner B | GPT-5.2-high (Codex CLI) | *skipped* | Alternative pragmatic perspective |
| Plan Synthesizer | Opus 4.6 | *skipped* | Strategic merge needs deep judgment |
| Plan Validator | Sonnet | Sonnet | Mechanical 7-dimension check |
| Sharpener | GPT-5.2-high (Codex CLI) | Opus 4.6 | Prompt engineer for target model's family |
| Implementer | GPT-5.3-codex-high (Codex CLI) | Sonnet | Code generation |
| E2E Verifier | Sonnet | Sonnet | Test generation + execution |
| Reviewer | Opus 4.6 | Opus 4.6 | Quality gate needs deep reasoning |
| Researcher | Haiku | Haiku | Fast retrieval, on-demand |
```

After the table, add: "GPT models appear in exactly three roles: Vision Challenger, Planner B, and Sharpener. These are 'GPT challenging Claude' or 'GPT writing prompts for GPT' roles. Detection is automatic: if `codex` CLI is on PATH and authenticated, multi-model activates."

### Section 3: Claude-Only Fallback Rules

Write a heading `## 3. Claude-Only Fallback Rules`. Write these rules as a bullet list:

- Brainstorm: Skip vision challenge pass. Single-perspective brainstorm (Opus only). No synthesis step.
- Planning: Skip Planner B and plan synthesis. Single Opus plan goes directly to validation.
- Sharpening: Opus generates Sonnet-optimized prompts (instead of GPT-5.2 generating Codex-optimized prompts).
- Execution: Sonnet implements directly (instead of GPT-5.3-codex via Codex CLI).
- All other stages: Unchanged (validation, E2E, review, reconcile work identically).
- Pipeline shape: Does NOT change. The same stages run in the same order. Only model assignments differ.
- Config: `modelMode` in `.kiln/config.json` controls this. Values: `"multi-model"` or `"claude-only"`.

### Section 4: Output Format Contracts

Write a heading `## 4. Agent Output Contracts`. Explain: "Each agent has a defined set of inputs (what it reads) and outputs (what it writes). Agents must NOT write outside their designated outputs."

Then write a sub-section for each agent as a definition list or structured bullets:

**Orchestrator** — Reads: STATE.md, ROADMAP.md, config.json. Writes: STATE.md updates (stage transitions only). Never writes source code.

**Brainstormer** — Reads: User input (interactive). Writes: .kiln/VISION.md (draft, then final after operator approval).

**Vision Challenger** (multi-model only) — Reads: .kiln/VISION.md (draft). Writes: .kiln/tracks/phase-N/vision_critique.md.

**Vision Synthesizer** (multi-model only) — Reads: .kiln/VISION.md (draft) + vision_critique.md. Writes: .kiln/VISION.md (final draft for operator approval).

**Planner A (Claude)** — Reads: VISION.md, ROADMAP.md, .kiln/docs/*, current codebase. Writes: .kiln/tracks/phase-N/plan_claude.md.

**Planner B (Codex)** (multi-model only) — Reads: Same as Planner A. Writes: .kiln/tracks/phase-N/plan_codex.md.

**Plan Synthesizer** (multi-model only) — Reads: plan_claude.md + plan_codex.md. Writes: .kiln/tracks/phase-N/PLAN.md (master plan with task packets).

**Plan Validator** — Reads: .kiln/tracks/phase-N/PLAN.md. Writes: validation result (sentinel block). No file output — pass/fail with feedback.

**Sharpener** — Reads: Task packet from PLAN.md + current codebase. Writes: Sharpened prompt (passed to Implementer, not saved to file).

**Implementer** — Reads: Sharpened prompt. Writes: Source code changes + atomic git commit.

**E2E Verifier** — Reads: PLAN.md acceptance criteria, current codebase, config.json (for start command). Writes: .kiln/tracks/phase-N/e2e-results.md, tests/e2e/phase-N-*.spec.* (committed to project).

**Reviewer** — Reads: Git diff (full track), PLAN.md, VISION.md, .kiln/docs/*, e2e-results.md. Writes: .kiln/tracks/phase-N/review.md.

**Reconciler** — Reads: Track changes (files created/modified). Writes: .kiln/docs/* updates, .kiln/tracks/phase-N/reconcile.md, STATE.md update.

**Researcher** — Reads: Query from any agent. Writes: Structured response (key findings with sources, relevant files/URLs, recommendation). On-demand, not file-based.

### Section 5: Sentinel Schema Format

Write a heading `## 5. Sentinel Schema`. Explain: "Sentinels are machine-readable YAML blocks embedded in markdown output. They enable deterministic parsing of agent results. Every agent that produces a pass/fail verdict must include a sentinel block."

Show this format:

````
```yaml
sentinel: <type>
status: pass | fail
timestamp: <ISO 8601>
details:
  <type-specific fields>
```
````

Then list the sentinel types:

- `plan-validation-result` — Fields: `dimensions_checked` (int), `dimensions_passed` (int), `failures` (list of {dimension, reason}).
- `e2e-result` — Fields: `tests_total` (int), `tests_passed` (int), `tests_failed` (int), `tests_skipped` (int), `failures` (list of {test_name, error, acceptance_criterion}).
- `review-verdict` — Fields: `verdict` (approved|rejected), `issues` (list of {severity, file, line, description, fix}).
- `task-status` — Fields: `task_id` (string), `result` (pass|fail), `retry_count` (int), `error` (string|null).

### Section 6: Context Budget Rules

Write a heading `## 6. Context Budget`. Write these rules:

- The orchestrator must stay under ~15% of its context window. It routes, spawns, and tracks — it never implements.
- Each task gets a fresh 200k-token subagent context. Task 1 and task 20 execute at equal quality.
- Task packets must be self-contained: goal, acceptance criteria, file hints, dependencies. No cross-task context leakage.
- Target ~50% context utilization per task (leave room for codebase reading and tool output).
- Wave grouping: independent tasks in the same wave run as concurrent subagents. Wave 1 completes before Wave 2 starts.
- Task sizing: 1-5 files per task, one clear goal, sized for a fresh subagent context.

### Section 7: Error Escalation Protocol

Write a heading `## 7. Error Escalation`. Write these rules as a structured list:

**Mini-verify (per task):**
- After each task: run project test suite + prior E2E tests (cumulative regression).
- On failure: re-sharpen with error context, retry implementation.
- Max 2 retries per task. After 2 failures: HALT.
- On halt: save error context to .kiln/tracks/phase-N/, report to operator.

**E2E verification (per track):**
- After all tasks in a track: run full E2E suite (new tests + regression).
- On failure: categorize (code bug, integration gap, missing functionality, config issue), generate correction task packets.
- Execute corrections via sharpen -> implement -> mini-verify -> re-run full E2E.
- Max 3 E2E correction cycles. After 3: HALT + escalate to operator.

**Code review (per track):**
- After E2E passes: comprehensive quality gate (correctness, completeness, security, integration, stubs, quality, regressions).
- On rejection: correction tasks with file:line specificity.
- Corrections re-trigger E2E (prevents fixes from breaking runtime).
- Max 3 review correction cycles. After 3: HALT + escalate to operator.

**On any HALT:**
- Save full error context, all retry attempts, and screenshots/logs to .kiln/tracks/phase-N/.
- Report to operator with: what failed, what was tried, actionable next steps.
- Do NOT silently continue or weaken acceptance criteria.

### Section 8: Stage Transitions

Write a heading `## 8. Pipeline Stages`. Show the canonical pipeline order:

```
init -> brainstorm -> roadmap -> [track loop] -> final integration E2E

Track loop (repeats for each phase in roadmap):
  plan -> validate -> execute -> e2e -> review -> reconcile
```

Rules:
- Only the orchestrator advances stages. Subagents report results; they do not decide the next step.
- HARD GATE after brainstorm: operator must explicitly approve VISION.md. No downstream stage runs without this.
- Track loop auto-advances through all phases. Pauses only for: reconcile confirmation, failures reaching halt threshold, or operator halt command.
- After ALL tracks complete: final integration E2E runs cross-cutting user journey tests that span multiple phases.

End the file with a brief closing note: "This document is the single source of truth for kiln's operational contracts. All agents and skills must reference and comply with these specifications."

Target ~300 lines total. Keep language prescriptive and unambiguous.

## ESTIMATED_DIFF
~300 lines

## RISKS
- If contracts are too vague, downstream agents will interpret them inconsistently
- If too verbose, it bloats every agent's context window when injected as a skill
- Model names/versions must exactly match the design spec

## ROLLBACK
- git revert <task commit>
