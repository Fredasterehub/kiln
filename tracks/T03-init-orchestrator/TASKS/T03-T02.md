# T03-T02: Write /kiln:init skill

## GOAL
Write the /kiln:init slash command skill that performs one-time project setup: detects project type, discovers existing tooling, checks for Codex CLI, creates the .kiln/ directory structure, and confirms the detected configuration with the operator.

## ACCEPTANCE_CRITERIA
- AC-02 (LLM): Handles greenfield, brownfield, and returning project detection with correct heuristics. Includes correct tooling discovery commands for all 5 tooling categories. Includes Codex CLI detection. Creates .kiln/ directory from templates. Confirms detected config with operator.

## FILES
- path: skills/kiln-init/kiln-init.md
  action: add
  rationale: The /kiln:init slash command skill — entry point for setting up kiln in a project

## COMMANDS
- `test -f skills/kiln-init/kiln-init.md` — file exists
- `wc -l skills/kiln-init/kiln-init.md` — should be ~250-400 lines

## SUMMARY
Create the file `skills/kiln-init/kiln-init.md`. This is a Claude Code skill file — a markdown document with YAML frontmatter that gets loaded when a user types `/kiln:init` in Claude Code. The skill contains instructions that the AI agent follows to perform the initialization.

**Context for the implementer:** Kiln is a multi-model orchestration workflow for Claude Code distributed as an NPM package. When a user installs kiln (via `npx kiln-dev`), agent and skill files are copied into their `.claude/` directory. The user then runs `/kiln:init` to set up kiln for their specific project. This skill detects the project's characteristics and creates a `.kiln/` directory with configuration. All state for kiln lives in `.kiln/`. The skill must work for any kind of project (Node.js, Python, Go, Rust, etc.).

Start the file with this YAML frontmatter:

```yaml
---
name: kiln-init
description: Initialize kiln for a project — detect project type, tooling, and model availability
user_invocable: true
---
```

Then write a markdown document with heading `# /kiln:init — Project Initialization` followed by these sections:

### Section 1: Overview

Write heading `## Overview`. Content:

"This skill performs one-time project setup for kiln. It detects what exists, configures kiln accordingly, and creates the state directory. It asks zero questions about workflow preferences — it detects everything automatically. The only user interaction is confirming the detected configuration.

**Prerequisites:** The kiln package must be installed (agents and skills present in `.claude/`). If `.kiln/` already exists with valid STATE.md, this is a 'returning' project — skip detection and resume.

**References:** This skill follows the contracts defined in kiln-core."

### Section 2: Project Type Detection

Write heading `## Step 1: Detect Project Type`. Content:

"Check the project root directory to classify the project:

**Returning project** (highest priority — check first):
- Check: Does `.kiln/` directory exist AND does `.kiln/STATE.md` exist?
- If yes: This is a returning project. Read STATE.md to determine where the previous session left off.
- Action: Print 'Returning project detected. Resuming from [last state].' Skip to Step 5 (Confirmation).

**Brownfield project** (existing code):
- Check: Does the project contain source code? Look for ANY of these indicators:
  - `src/` directory exists
  - `lib/` directory exists
  - `app/` directory exists
  - `package.json` exists (Node.js)
  - `requirements.txt` or `pyproject.toml` or `setup.py` exists (Python)
  - `go.mod` exists (Go)
  - `Cargo.toml` exists (Rust)
  - `pom.xml` or `build.gradle` exists (Java)
  - `*.sln` or `*.csproj` exists (C#/.NET)
- If any match: This is a brownfield project. Existing code must be respected.
- Action: Set `projectType` to `'brownfield'`.

**Greenfield project** (no existing code):
- If none of the brownfield indicators match: This is a greenfield project. Starting from scratch.
- Action: Set `projectType` to `'greenfield'`."

### Section 3: Tooling Discovery

Write heading `## Step 2: Discover Existing Tooling`. Content:

"For brownfield projects, detect existing tooling. For greenfield projects, all values will be `null` (nothing to detect yet — tooling will be established during implementation).

Run these detection checks. Use the Bash tool to execute each command. If the command succeeds (exit 0), record the tool name. If it fails, set that category to `null`.

**Test Runner** — check in this priority order (first match wins):
1. `grep -q '"vitest"' package.json 2>/dev/null` → `'vitest'`
2. `grep -q '"jest"' package.json 2>/dev/null` → `'jest'`
3. `grep -q '"mocha"' package.json 2>/dev/null` → `'mocha'`
4. `test -f pytest.ini || test -f pyproject.toml && grep -q 'pytest' pyproject.toml 2>/dev/null` → `'pytest'`
5. `test -f go.mod` → `'go test'`
6. `test -f Cargo.toml` → `'cargo test'`
7. None found → `null`

**Linter** — check in this priority order:
1. `grep -q '"eslint"' package.json 2>/dev/null` → `'eslint'`
2. `grep -q '"biome"' package.json 2>/dev/null` → `'biome'`
3. `test -f .eslintrc* || test -f eslint.config.*` → `'eslint'`
4. `grep -q 'ruff' pyproject.toml 2>/dev/null || test -f ruff.toml` → `'ruff'`
5. `grep -q 'flake8' pyproject.toml 2>/dev/null || test -f .flake8` → `'flake8'`
6. `test -f .golangci.yml || test -f .golangci.yaml` → `'golangci-lint'`
7. None found → `null`

**Type Checker** — check in this priority order:
1. `test -f tsconfig.json` → `'tsc'`
2. `grep -q 'mypy' pyproject.toml 2>/dev/null || test -f mypy.ini` → `'mypy'`
3. `grep -q 'pyright' pyproject.toml 2>/dev/null` → `'pyright'`
4. None found → `null` (Go and Rust have built-in type checking via their compilers)

**Build System** — check in this priority order:
1. `grep -q '"build"' package.json 2>/dev/null` → `'npm run build'`
2. `test -f Makefile` → `'make'`
3. `test -f Cargo.toml` → `'cargo build'`
4. `test -f go.mod` → `'go build ./...'`
5. None found → `null`

**Start Command** — check in this priority order:
1. `grep -q '"dev"' package.json 2>/dev/null` → `'npm run dev'`
2. `grep -q '"start"' package.json 2>/dev/null` → `'npm start'`
3. `test -f manage.py` → `'python manage.py runserver'`
4. `test -f app.py` → `'python app.py'`
5. `test -f main.py` → `'python main.py'`
6. `test -f main.go` → `'go run main.go'`
7. `test -f Cargo.toml` → `'cargo run'`
8. None found → `null`"

### Section 4: Codex CLI Detection

Write heading `## Step 3: Detect Model Availability`. Content:

"Check if Codex CLI is available for multi-model mode:

1. Run: `which codex 2>/dev/null`
   - If not found: Set `modelMode` to `'claude-only'`. Print: 'Codex CLI not found. Running in Claude-only mode.'
   - If found: Continue to authentication check.

2. Run: `codex --version 2>/dev/null`
   - If this succeeds: Set `modelMode` to `'multi-model'`. Print: 'Codex CLI detected (version X). Multi-model mode enabled.'
   - If this fails: Set `modelMode` to `'claude-only'`. Print: 'Codex CLI found but not properly configured. Running in Claude-only mode.'

Note: The user can override this later by editing `.kiln/config.json` directly."

### Section 5: Create .kiln/ Directory

Write heading `## Step 4: Create .kiln/ Directory`. Content:

"Create the kiln state directory structure. Use the templates from the kiln package.

1. Create directories:
   ```
   mkdir -p .kiln/docs
   mkdir -p .kiln/tracks
   ```

2. Create `config.json` from template:
   - Read the template from `templates/config.json.tmpl` (relative to the kiln package install location, which is `.claude/skills/kiln-init/../../templates/` or find it via glob)
   - If the template can't be found, create the JSON directly with the detected values:
   ```json
   {
     \"projectType\": \"<detected>\",
     \"modelMode\": \"<detected>\",
     \"tooling\": {
       \"testRunner\": <detected or null>,
       \"linter\": <detected or null>,
       \"typeChecker\": <detected or null>,
       \"buildSystem\": <detected or null>,
       \"startCommand\": <detected or null>
     },
     \"preferences\": {
       \"maxRetries\": 2,
       \"waveParallelism\": 3,
       \"e2eTimeout\": 30000
     }
   }
   ```
   - Fill in detected values from Steps 1-3.

3. Create `STATE.md` from template:
   - Read from `templates/STATE.md.tmpl`
   - Fill in: project name (from directory name or package.json `name` field), model mode, initialization timestamp (ISO 8601)
   - Set all other fields to initial values (no phases yet, no current track, zero correction cycles, zero regression tests)

4. Create empty living doc placeholders:
   ```
   touch .kiln/docs/TECH_STACK.md
   touch .kiln/docs/PATTERNS.md
   touch .kiln/docs/DECISIONS.md
   touch .kiln/docs/PITFALLS.md
   ```

5. Add `.kiln/` to `.gitignore` if not already present:
   - Check: `grep -q '.kiln/' .gitignore 2>/dev/null`
   - If not present: append `.kiln/` to `.gitignore`

   Actually, `.kiln/` should be committed to git (full auditability per kiln-core contracts). Do NOT add it to .gitignore."

### Section 6: Operator Confirmation

Write heading `## Step 5: Confirm Configuration`. Content:

"Display the detected configuration to the operator and ask for confirmation:

```
Kiln initialized for: <project_name>

Project type: <greenfield|brownfield|returning>
Model mode:   <multi-model|claude-only>

Detected tooling:
  Test runner:   <value or 'not detected'>
  Linter:        <value or 'not detected'>
  Type checker:  <value or 'not detected'>
  Build system:  <value or 'not detected'>
  Start command: <value or 'not detected'>

Preferences (defaults):
  Max retries per task: 2
  Wave parallelism:     3
  E2E timeout:          30s

.kiln/ directory created.
```

Ask: 'Does this configuration look correct? You can edit .kiln/config.json manually at any time to adjust these values.'

If the operator confirms: Print 'Initialization complete. Run /kiln:brainstorm to start.' (or 'Run /kiln:status to see where you left off.' for returning projects).

If the operator wants changes: Let them specify corrections. Update config.json accordingly. Re-display and re-confirm."

### Section 7: Error Handling

Write heading `## Error Handling`. Content:

"- If `.kiln/` already exists and this is NOT a returning project (no STATE.md): warn the operator that `.kiln/` exists but appears incomplete. Ask if they want to reinitialize (will overwrite existing config).
- If template files cannot be found: create config.json and STATE.md with hardcoded defaults rather than failing.
- If any detection command hangs: use a 5-second timeout per command. Treat timeout as 'not detected'."

Target ~350 lines.

## ESTIMATED_DIFF
~350 lines

## RISKS
- Tooling detection commands may not work on all platforms (especially Windows/WSL)
- Template file paths depend on how kiln is installed — may need fallback
- Returning project detection must handle corrupted STATE.md gracefully

## ROLLBACK
- git revert <task commit>
