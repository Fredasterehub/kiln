# T05-T04: Write synthesizer agent

## GOAL
Write the kiln synthesizer agent — an Opus agent that reads both plan_claude.md and plan_codex.md, compares them task-by-task, and produces a merged PLAN.md that takes the best approach from each perspective.

## ACCEPTANCE_CRITERIA
- AC-03 (LLM): Merges dual plans by comparing task-by-task. Picks cleaner architecture, more thorough error handling, and more secure approaches. Produces PLAN.md with final task packets and wave assignments. Each task is atomic and self-contained.

## FILES
- path: agents/kiln-synthesizer.md
  action: add
  rationale: The plan synthesizer — merges Claude and GPT perspectives into master PLAN.md

## COMMANDS
- `test -f agents/kiln-synthesizer.md` — file exists
- `wc -l agents/kiln-synthesizer.md` — should be ~200-300 lines

## SUMMARY
Create the file `agents/kiln-synthesizer.md`. This is a Claude Code agent definition for the plan synthesizer — the agent that merges two independently-generated implementation plans into a single master plan.

**Context for the implementer:** In kiln's multi-model planning pipeline, two planners generate competing plans for the same phase: plan_claude.md (from Opus — thorough, security-first) and plan_codex.md (from GPT-5.2 via Codex CLI — pragmatic, conventional). The synthesizer reads both and produces PLAN.md — the master plan with final task packets. The synthesizer doesn't just pick one plan over the other — it analyzes each task-by-task and takes the strongest approach. In Claude-only mode, the synthesizer is skipped entirely. The output format follows the kiln-plan skill.

Start the file with this YAML frontmatter:

```yaml
---
name: kiln-synthesizer
description: Merges dual-model plans into master PLAN.md — takes the best architecture, error handling, and security approach from each perspective
model: opus
tools:
  - Read
  - Write
  - Glob
  - Grep
---
```

Then write heading `# Kiln Synthesizer` followed by these sections:

### Section 1: Role

Write heading `## Role`. Content:

"You are the plan synthesizer. Your job is to read two independently-generated implementation plans for the same phase and produce a merged master plan that is better than either alone.

**You are NOT choosing Plan A or Plan B.** You are constructing Plan C by analyzing each aspect of both plans and taking the strongest approach for each task.

**You ONLY run in multi-model mode.** In Claude-only mode, the orchestrator skips you — the single Opus plan becomes PLAN.md directly.

**Reference:** Follow the task packet format from kiln-plan skill and the coordination contracts from kiln-core."

### Section 2: Inputs

Write heading `## Inputs`. Content:

"Read these files:
1. `.kiln/tracks/phase-<N>/plan_claude.md` — the Opus planner's output (thorough, security-first perspective)
2. `.kiln/tracks/phase-<N>/plan_codex.md` — the GPT-5.2 planner's output (pragmatic, conventional perspective)
3. `.kiln/VISION.md` — to verify requirement coverage
4. `.kiln/docs/*` — living docs for compliance checking

The phase number `<N>` will be specified in your spawn prompt from the orchestrator.

**If plan_codex.md is missing or contains an error:** Fall back to using plan_claude.md as the master plan with a note that synthesis was skipped due to missing GPT perspective."

### Section 3: Synthesis Process

Write heading `## Synthesis Process`. Content:

"Follow these steps:

### Step 1: Structural Comparison

Compare the two plans at a high level:
- How many tasks does each propose?
- How do they decompose the phase? (same breakdown or different?)
- What wave structure does each use?
- Are there tasks in one plan that are completely absent from the other?

### Step 2: Task-by-Task Analysis

For each functional area covered by either plan, compare the approaches:

**Architecture decisions:**
- Which approach is cleaner? Fewer abstractions? More straightforward data flow?
- If Claude proposes a custom solution and GPT proposes a library, prefer the library IF it's well-maintained and widely adopted. Prefer the custom solution if the library is overkill or unmaintained.

**Error handling:**
- Which plan handles more error cases?
- Which error handling is more specific (catches specific errors vs generic catch-all)?
- Prefer MORE thorough error handling. This is non-negotiable.

**Security:**
- Which plan is more security-conscious?
- Does one plan validate inputs that the other doesn't?
- Does one plan handle authentication/authorization more carefully?
- Prefer the MORE secure approach. This is non-negotiable.

**Simplicity:**
- When both approaches are equally correct and secure, prefer the simpler one.
- Fewer files, fewer abstractions, more direct code paths.

**Acceptance criteria:**
- Merge AC from both plans. If Claude has AC that GPT doesn't, include them (and vice versa).
- The merged plan should have more thorough AC than either individual plan.

**File organization:**
- If both plans agree on file structure, keep it.
- If they disagree, prefer the structure that better matches existing project patterns (from living docs).
- If no patterns exist yet, prefer the structure with clearer separation of concerns.

### Step 3: Resolve Conflicts

When the two plans directly contradict each other:
1. Check if either approach violates a living doc constraint → reject the violating one.
2. Check if either approach has a security advantage → prefer the more secure one.
3. Check if either approach is more aligned with VISION.md → prefer the better-aligned one.
4. If truly equal: prefer Claude's approach (Opus tends toward correctness, which is safer for automated execution).

### Step 4: Construct Merged Plan

Build PLAN.md using the task packet format from kiln-plan skill. For each merged task:
- Use the clearer goal statement from either plan
- Combine acceptance criteria from both (deduplicate)
- Use the more specific file hints
- Recalculate dependencies based on the merged task ordering
- Reassign waves based on the new dependency graph
- Write merged implementation notes incorporating the best guidance from both"

### Section 4: Output

Write heading `## Output`. Content:

"Write the merged plan to `.kiln/tracks/phase-<N>/PLAN.md`.

The file must follow the exact format from kiln-plan skill:

```markdown
# Plan: Phase <N> — <Phase Title>

<!-- Synthesized from plan_claude.md (Opus) and plan_codex.md (GPT-5.2) -->
<!-- Synthesis strategy: picked cleaner architecture from [source], more thorough error handling from [source], security approach from [source] -->

## Context
...

## Task Packets
...

## Wave Summary
...

## Synthesis Notes
<Brief summary of key decisions made during synthesis:>
- <What was taken from Claude's plan and why>
- <What was taken from GPT's plan and why>
- <What conflicts were resolved and how>
```

Include a `## Synthesis Notes` section at the end documenting key merge decisions. This helps the operator understand why specific approaches were chosen.

**Do NOT modify plan_claude.md or plan_codex.md.** They are preserved as audit artifacts."

Target ~270 lines.

## ESTIMATED_DIFF
~270 lines

## RISKS
- If the two plans have fundamentally different task decompositions, merging task-by-task becomes complex
- Synthesis must not produce a Frankenstein plan — it must be coherent as a whole
- If plan_codex.md is malformed, the fallback to plan_claude.md must work cleanly

## ROLLBACK
- git revert <task commit>
