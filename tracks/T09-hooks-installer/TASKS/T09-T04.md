# T09-T04: Write full installer

## GOAL
Replace the bin/install.js stub with a full interactive installer that copies kiln agents, skills, and hooks into a user's project, creates the .kiln/ directory from templates, merges with existing Claude Code configurations, and provides a guided setup experience. Zero runtime dependencies — Node.js built-ins only.

## ACCEPTANCE_CRITERIA
- AC-02 (DET): `node bin/install.js --help` shows usage and exits 0
- AC-03 (DET): Installer copies agents/, skills/, hooks/ to correct .claude/ destinations
- AC-04 (DET): Installer creates .kiln/ directory structure from templates
- AC-07 (DET): hooks.json merge works correctly (combines existing + kiln hooks)
- AC-08 (DET): Zero runtime dependencies — only uses fs, path, readline from Node.js built-ins

## FILES
- path: bin/install.js
  action: modify
  rationale: Replace the stub with full implementation

## COMMANDS
- `node bin/install.js --help` — shows usage, exits 0
- `node -e "require('./bin/install.js')" -- --help` — no syntax errors
- `grep -c "require(" bin/install.js | head -1` — should only import built-in modules (fs, path, readline)

## SUMMARY
Replace the stub at `bin/install.js` with a full interactive installer. The current stub (from T01) only parses --help and --repo-root. The full installer needs to handle the complete installation flow.

**Context for the implementer:** This is the main user-facing entry point for kiln. Users run `npx kiln-dev` which invokes this script. It must work in any Node.js project directory, handle existing Claude Code configurations gracefully, and set up the complete kiln workspace. Zero runtime dependencies is a hard requirement — use only `fs`, `path`, and `readline` from Node.js standard library.

### Keep the existing structure
Preserve the existing shebang, USAGE string, and argument parsing. Extend with new flags:
- `--yes` or `-y`: Non-interactive mode, accept all defaults
- `--global`: Install to ~/.claude/ (global) instead of project .claude/ (local)
- Keep existing: `--help`, `--repo-root <path>`

### Installation Flow

**Step 1: Detect environment**
- Verify Node.js version (minimum 18)
- Check if .claude/ directory exists at repo root (detect existing Claude Code setup)
- Check if .kiln/ exists (detect returning user)
- Check for Codex CLI: run `which codex` to detect availability

**Step 2: Determine install targets**
- Source directory: the kiln package directory (where install.js lives: `__dirname + '/..''`)
- Target directory: the repo root's .claude/ directory (or ~/.claude/ if --global)
- If .claude/ doesn't exist: create it
- If .claude/ exists: prepare for merge mode

**Step 3: Interactive prompts** (skip if --yes)
- Ask: "Install kiln to [repo-root]? (Y/n)"
- If existing .claude/ detected: "Existing Claude Code config found. Merge kiln files alongside existing? (Y/n)"
- Report Codex CLI status: "Codex CLI detected — multi-model mode available" or "Codex CLI not found — kiln will run in Claude-only mode"

**Step 4: Copy agents**
- Source: `<package>/agents/*.md`
- Target: `<repo-root>/.claude/agents/`
- Read all .md files from source agents/ directory
- For each file: copy to target, skip if identical file already exists, warn if different file exists with same name
- Report: "Copied N agent files to .claude/agents/"

**Step 5: Copy skills**
- Source: `<package>/skills/*/`
- Target: `<repo-root>/.claude/skills/`
- Read all skill directories from source skills/ directory
- For each directory: create target directory, copy all files within
- Same skip/warn logic as agents
- Report: "Copied N skill directories to .claude/skills/"

**Step 6: Copy and merge hooks**
- Source: `<package>/hooks/`
- Target: `<repo-root>/.claude/hooks/`
- Copy `hooks/scripts/*.sh` to `.claude/hooks/scripts/`
- For hooks.json: if target hooks.json exists, MERGE (combine hook arrays, avoid duplicates). If not, copy directly.
- Merging hooks.json: read both JSON files, combine the hooks arrays, write merged result
- Report: "Installed hooks (N hook scripts, hooks.json [created|merged])"

**Step 7: Create .kiln/ directory**
- Create `.kiln/` at repo root
- Read `templates/config.json.tmpl` and write `.kiln/config.json` with detected values:
  - `projectType`: detect from existing files (package.json = node, Cargo.toml = rust, etc.)
  - `modelMode`: "multi-model" if Codex detected, "claude-only" otherwise
  - `tooling`: detect test runner, linter, type checker, build system, start command from package.json scripts
- Read `templates/STATE.md.tmpl` and write `.kiln/STATE.md` with initial values
- Create `.kiln/docs/` directory (empty, populated later by reconcile)
- Create `.kiln/tracks/` directory (empty, populated by track execution)

**Step 8: Update .gitignore**
- Read existing .gitignore (or create if missing)
- Add `.kiln/` if not already present
- Do NOT add .claude/ (user may want to version control their agent configs)

**Step 9: Success message**
- Print installation summary: what was installed, where
- Print detected configuration: project type, model mode, tooling
- Print next steps: "Run /kiln:brainstorm to start building, or /kiln:quick for single-pass mode"

### Helper functions to implement
- `copyDir(src, dest)` — recursive directory copy using fs.mkdirSync + fs.copyFileSync
- `mergeHooksJson(existing, kiln)` — merge two hooks.json files
- `detectProjectType(repoRoot)` — check for package.json, Cargo.toml, go.mod, pyproject.toml, etc.
- `detectTooling(repoRoot)` — parse package.json scripts for test/lint/build/start commands
- `prompt(question)` — readline-based interactive prompt, returns promise
- `detectCodexCli()` — run `which codex` and check exit code

### Implementation constraints
- ONLY use: `require('fs')`, `require('path')`, `require('readline')`
- No `require('child_process')` except for Codex CLI detection (use spawnSync for that one check)
- All file operations use synchronous fs methods (simpler, installer is not performance-critical)
- Handle errors gracefully: catch ENOENT, EACCES, show user-friendly messages
- All paths must be resolved properly (no hardcoded absolute paths)

Target ~250-350 lines.

## ESTIMATED_DIFF
~300 lines

## RISKS
- Merge logic for hooks.json is the most complex part — edge cases with duplicate hooks
- Project type detection may fail for unusual project layouts
- Cross-platform path handling (Windows backslashes vs Unix forward slashes)

## ROLLBACK
- git revert <task commit>
